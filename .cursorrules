<file_length_and_structure>
- Never allow a file to exceed 500 lines.
- If a file approaches 400 lines, break it up immediately.
- Treat 1000 lines as unacceptable, even temporarily.
- Use folders and naming conventions to keep small files logically grouped.
</file_length_and_structure>

<oop_first>
- Every functionality should be in a dedicated class, struct, or protocol, even if it’s small.
- Favor composition over inheritance, but always use object-oriented thinking.
- Code must be built for reuse, not just to “make it work.”
</oop_first>

<single_responsibility_principle>
- Every file, class, and function should do one thing only.
- If it has multiple responsibilities, split it immediately.
- Each view, manager, or utility should be laser-focused on one concern.
</single_responsibility_principle>

<modular_design>
- Code should connect like Lego – interchangeable, testable, and isolated.
- Ask: “Can I reuse this class in a different screen or project?” If not, refactor it.
- Reduce tight coupling between components. Favor dependency injection or protocols.
</modular_design>

<manager_and_coordinator_patterns>
- Use ViewModel, Manager, and Coordinator naming conventions for logic separation:
  – UI logic → ViewModel
  – Business logic → Manager
  – Navigation/state flow → Coordinator
- Never mix views and business logic directly.
</manager_and_coordinator_patterns>

<function_and_class_size>
- Keep functions under 30–40 lines.
- If a class is over 200 lines, assess splitting into smaller helper classes.
</function_and_class_size>

<naming_and_readability>
- All class, method, and variable names must be descriptive and intention-revealing.
- Avoid vague names like data, info, helper, or temp.
</naming_and_readability>

<scalability_mindset>
- Always code as if someone else will scale this.
- Include extension points (e.g., protocol conformance, dependency injection) from day one.
</scalability_mindset>

<avoid_god_classes>
- Never let one file or class hold everything (e.g., massive ViewController, ViewModel, or Service).
- Split into UI, State, Handlers, Networking, etc.
</avoid_god_classes>


# CSS Organization Rules

## NEVER put CSS or styles directly in .tsx files
- All CSS must be in separate .css files
- Use CSS Modules (.module.css) for component-specific styles
- Use globals.css only for truly global styles
- **ABSOLUTELY NO inline styles in JSX** (style={{...}})
- **ABSOLUTELY NO className with template literals** for dynamic styles

## CSS File Organization:
- `src/styles/globals.css` - Global styles, CSS variables, resets
- `src/styles/[component].module.css` - Component-specific styles
- `src/styles/[feature].module.css` - Feature-specific styles

## Before adding any CSS or style:
0. Evaluate if there is an existing matching css class
1. Evaluate if it's truly global → use globals.css
2. Is it component-specific → use [component].module.css
3. Is it feature-specific → use [feature].module.css
4. **NEVER use inline styles** - always create CSS classes
5. **NEVER use dynamic className generation** - use CSS variables or conditional classes

## CSS Class Naming Conventions:
- Use descriptive, semantic class names
- Use kebab-case for class names
- Use BEM methodology when appropriate
- Group related styles together
- Use CSS variables for dynamic values

## Dynamic Styling Solutions:
- Use CSS variables for dynamic values: `--custom-property: value`
- Use conditional classes: `className={condition ? 'class-a' : 'class-b'}`
- Use CSS modules with computed class names
- Use CSS-in-JS libraries only when absolutely necessary

## Always ask before adding CSS:
- "Should this go in globals.css or a module?"
- "Is this style reusable across components?"
- "Can this be achieved with CSS variables?"
- "Is there an existing class I can reuse or extend?"
- "Can I avoid inline styles by creating a proper CSS class?"

# TypeScript & Build Rules

## NEVER use `any` type
- Use proper types: `(obj as { prop: string }).prop` instead of `(obj as any).prop`
- Create interfaces for complex objects
- Use `unknown` only when type is truly unknown

## Handle Optional Properties
- Always use `??` for optional properties: `value.prop ?? defaultValue`
- Check for undefined: `(obj.prop ?? '')` for strings, `(obj.prop ?? 0)` for numbers
- Use type guards: `'prop' in obj` instead of `(obj as any).prop`

## Build Compliance
- If change is complex, it must pass `npm run build` without errors
- Always before run npm run build, make sure all "npm run dev" process are killed
- Remove unused functions and variables immediately
- Use proper type assertions, not `any`
- Handle all possible undefined values

## Before generating code:
1. "Will this pass TypeScript strict mode?"
2. "Are all optional properties handled with `??`?"
3. "Am I using proper types instead of `any`?"